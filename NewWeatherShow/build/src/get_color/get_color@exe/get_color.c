/* get_color.c generated by valac 0.40.4, the Vala compiler
 * generated from get_color.vala, do not modify */



#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <float.h>
#include <math.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>


#define TYPE_COLOR_PICKER (color_picker_get_type ())
#define COLOR_PICKER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COLOR_PICKER, ColorPicker))
#define COLOR_PICKER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COLOR_PICKER, ColorPickerClass))
#define IS_COLOR_PICKER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COLOR_PICKER))
#define IS_COLOR_PICKER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COLOR_PICKER))
#define COLOR_PICKER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COLOR_PICKER, ColorPickerClass))

typedef struct _ColorPicker ColorPicker;
typedef struct _ColorPickerClass ColorPickerClass;
typedef struct _ColorPickerPrivate ColorPickerPrivate;
enum  {
	COLOR_PICKER_0_PROPERTY,
	COLOR_PICKER_NUM_PROPERTIES
};
static GParamSpec* color_picker_properties[COLOR_PICKER_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _ColorPicker {
	GtkWindow parent_instance;
	ColorPickerPrivate * priv;
};

struct _ColorPickerClass {
	GtkWindowClass parent_class;
};

struct _ColorPickerPrivate {
	GtkColorChooserWidget* color;
	gdouble red1;
	gdouble red2;
	gdouble green1;
	gdouble green2;
	gdouble blue1;
	gdouble blue2;
	GSettings* settings;
	GtkSpinButton* redbutton;
	GtkSpinButton* greenbutton;
	GtkSpinButton* bluebutton;
};


static gpointer color_picker_parent_class = NULL;

GType color_picker_get_type (void) G_GNUC_CONST;
#define COLOR_PICKER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_COLOR_PICKER, ColorPickerPrivate))
ColorPicker* color_picker_new (void);
ColorPicker* color_picker_construct (GType object_type);
static void _gtk_main_quit_gtk_widget_destroy (GtkWidget* _sender,
                                        gpointer self);
static void color_picker_get_fromrgbspins (ColorPicker* self,
                                    GtkSpinButton* button);
static void _color_picker_get_fromrgbspins_gtk_spin_button_value_changed (GtkSpinButton* _sender,
                                                                   gpointer self);
static void color_picker_update_gsettings (ColorPicker* self,
                                    GtkButton* button);
static void _color_picker_update_gsettings_gtk_button_clicked (GtkButton* _sender,
                                                        gpointer self);
static void __lambda4_ (ColorPicker* self);
static void ___lambda4__gtk_button_clicked (GtkButton* _sender,
                                     gpointer self);
static gboolean __lambda5_ (ColorPicker* self);
static gboolean ___lambda5__gsource_func (gpointer self);
static void color_picker_get_currgsettings (ColorPicker* self);
static gint* color_picker_get_newcolor (ColorPicker* self,
                                 int* result_length1);
static void _vala_array_add1 (gchar** * array,
                       int* length,
                       int* size,
                       gchar* value);
static void _vala_array_add2 (gint* * array,
                       int* length,
                       int* size,
                       gint value);
static void color_picker_finalize (GObject * obj);
gint _vala_main (gchar** args,
                 int args_length1);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static void
_gtk_main_quit_gtk_widget_destroy (GtkWidget* _sender,
                                   gpointer self)
{
	gtk_main_quit ();
}


static void
_color_picker_get_fromrgbspins_gtk_spin_button_value_changed (GtkSpinButton* _sender,
                                                              gpointer self)
{
	color_picker_get_fromrgbspins ((ColorPicker*) self, _sender);
}


static void
_color_picker_update_gsettings_gtk_button_clicked (GtkButton* _sender,
                                                   gpointer self)
{
	color_picker_update_gsettings ((ColorPicker*) self, _sender);
}


static void
__lambda4_ (ColorPicker* self)
{
	gtk_main_quit ();
}


static void
___lambda4__gtk_button_clicked (GtkButton* _sender,
                                gpointer self)
{
	__lambda4_ ((ColorPicker*) self);
}


static gboolean
__lambda5_ (ColorPicker* self)
{
	gboolean result = FALSE;
	GdkRGBA newcolor = {0};
	GtkColorChooserWidget* _tmp0_;
	GdkRGBA _tmp1_ = {0};
	GdkRGBA _tmp2_;
	gdouble _tmp3_;
	GdkRGBA _tmp4_;
	gdouble _tmp5_;
	GdkRGBA _tmp6_;
	gdouble _tmp7_;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_ = FALSE;
	gdouble _tmp10_;
	gdouble _tmp11_;
	gboolean test = FALSE;
	gboolean _tmp16_;
	gdouble _tmp23_;
	gdouble _tmp24_;
	gdouble _tmp25_;
	_tmp0_ = self->priv->color;
	gtk_color_chooser_get_rgba ((GtkColorChooser*) _tmp0_, &_tmp1_);
	newcolor = _tmp1_;
	_tmp2_ = newcolor;
	_tmp3_ = _tmp2_.red;
	self->priv->red2 = _tmp3_;
	_tmp4_ = newcolor;
	_tmp5_ = _tmp4_.green;
	self->priv->green2 = _tmp5_;
	_tmp6_ = newcolor;
	_tmp7_ = _tmp6_.blue;
	self->priv->blue2 = _tmp7_;
	_tmp10_ = self->priv->red2;
	_tmp11_ = self->priv->red1;
	if (_tmp10_ == _tmp11_) {
		gdouble _tmp12_;
		gdouble _tmp13_;
		_tmp12_ = self->priv->green2;
		_tmp13_ = self->priv->green1;
		_tmp9_ = _tmp12_ == _tmp13_;
	} else {
		_tmp9_ = FALSE;
	}
	if (_tmp9_) {
		gdouble _tmp14_;
		gdouble _tmp15_;
		_tmp14_ = self->priv->blue2;
		_tmp15_ = self->priv->blue1;
		_tmp8_ = _tmp14_ == _tmp15_;
	} else {
		_tmp8_ = FALSE;
	}
	test = !_tmp8_;
	_tmp16_ = test;
	if (_tmp16_ == TRUE) {
		GtkSpinButton* _tmp17_;
		gdouble _tmp18_;
		GtkSpinButton* _tmp19_;
		gdouble _tmp20_;
		GtkSpinButton* _tmp21_;
		gdouble _tmp22_;
		_tmp17_ = self->priv->redbutton;
		_tmp18_ = self->priv->red2;
		gtk_spin_button_set_value (_tmp17_, (gdouble) ((gint) round (_tmp18_ * 255)));
		_tmp19_ = self->priv->greenbutton;
		_tmp20_ = self->priv->green2;
		gtk_spin_button_set_value (_tmp19_, (gdouble) ((gint) round (_tmp20_ * 255)));
		_tmp21_ = self->priv->bluebutton;
		_tmp22_ = self->priv->blue2;
		gtk_spin_button_set_value (_tmp21_, (gdouble) ((gint) round (_tmp22_ * 255)));
	}
	_tmp23_ = self->priv->red2;
	self->priv->red1 = _tmp23_;
	_tmp24_ = self->priv->green2;
	self->priv->green1 = _tmp24_;
	_tmp25_ = self->priv->blue2;
	self->priv->blue1 = _tmp25_;
	result = TRUE;
	return result;
}


static gboolean
___lambda5__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda5_ ((ColorPicker*) self);
	return result;
}


ColorPicker*
color_picker_construct (GType object_type)
{
	ColorPicker * self = NULL;
	GSettings* _tmp0_;
	GtkGrid* maingrid = NULL;
	GtkGrid* _tmp1_;
	GtkGrid* _tmp2_;
	GtkGrid* _tmp3_;
	GtkColorChooserWidget* _tmp4_;
	GtkColorChooserWidget* _tmp5_;
	GtkColorChooserWidget* _tmp6_;
	GtkGrid* _tmp7_;
	GtkColorChooserWidget* _tmp8_;
	GtkGrid* spinboxgrid = NULL;
	GtkGrid* _tmp9_;
	GtkGrid* _tmp10_;
	GtkGrid* _tmp11_;
	GtkGrid* _tmp12_;
	gint index = 0;
	gchar** rgblabels = NULL;
	gchar* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	gchar** _tmp16_;
	gint rgblabels_length1;
	gint _rgblabels_size_;
	gchar** _tmp17_;
	gint _tmp17__length1;
	GtkSpinButton* _tmp29_;
	GtkSpinButton* _tmp30_;
	GtkGrid* _tmp31_;
	GtkSpinButton* _tmp32_;
	GtkSpinButton* _tmp33_;
	GtkSpinButton* _tmp34_;
	GtkGrid* _tmp35_;
	GtkSpinButton* _tmp36_;
	GtkSpinButton* _tmp37_;
	GtkSpinButton* _tmp38_;
	GtkGrid* _tmp39_;
	GtkSpinButton* _tmp40_;
	GtkBox* buttonbox = NULL;
	GtkBox* _tmp41_;
	GtkGrid* _tmp42_;
	GtkButton* apply_button = NULL;
	GtkButton* _tmp43_;
	GtkButton* cancel_button = NULL;
	GtkButton* _tmp44_;
	self = (ColorPicker*) g_object_new (object_type, NULL);
	_tmp0_ = g_settings_new ("org.ubuntubudgie.plugins.weathershow");
	_g_object_unref0 (self->priv->settings);
	self->priv->settings = _tmp0_;
	_tmp1_ = (GtkGrid*) gtk_grid_new ();
	g_object_ref_sink (_tmp1_);
	maingrid = _tmp1_;
	_tmp2_ = maingrid;
	gtk_container_set_border_width ((GtkContainer*) _tmp2_, (guint) 20);
	_tmp3_ = maingrid;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp3_);
	gtk_window_set_focus_on_map ((GtkWindow*) self, TRUE);
	gtk_window_set_title ((GtkWindow*) self, "Set text color");
	g_signal_connect ((GtkWidget*) self, "destroy", (GCallback) _gtk_main_quit_gtk_widget_destroy, NULL);
	gtk_window_set_skip_taskbar_hint ((GtkWindow*) self, TRUE);
	_tmp4_ = (GtkColorChooserWidget*) gtk_color_chooser_widget_new ();
	g_object_ref_sink (_tmp4_);
	_g_object_unref0 (self->priv->color);
	self->priv->color = _tmp4_;
	_tmp5_ = self->priv->color;
	gtk_color_chooser_set_use_alpha ((GtkColorChooser*) _tmp5_, FALSE);
	_tmp6_ = self->priv->color;
	g_object_set (_tmp6_, "show-editor", TRUE, NULL);
	_tmp7_ = maingrid;
	_tmp8_ = self->priv->color;
	gtk_grid_attach (_tmp7_, (GtkWidget*) _tmp8_, 0, 0, 1, 10);
	_tmp9_ = (GtkGrid*) gtk_grid_new ();
	g_object_ref_sink (_tmp9_);
	spinboxgrid = _tmp9_;
	_tmp10_ = maingrid;
	_tmp11_ = spinboxgrid;
	gtk_grid_attach (_tmp10_, (GtkWidget*) _tmp11_, 1, 0, 1, 1);
	_tmp12_ = spinboxgrid;
	gtk_grid_set_column_homogeneous (_tmp12_, TRUE);
	index = 0;
	_tmp13_ = g_strdup ("Red");
	_tmp14_ = g_strdup ("Green");
	_tmp15_ = g_strdup ("Blue");
	_tmp16_ = g_new0 (gchar*, 3 + 1);
	_tmp16_[0] = _tmp13_;
	_tmp16_[1] = _tmp14_;
	_tmp16_[2] = _tmp15_;
	rgblabels = _tmp16_;
	rgblabels_length1 = 3;
	_rgblabels_size_ = rgblabels_length1;
	_tmp17_ = rgblabels;
	_tmp17__length1 = rgblabels_length1;
	{
		gchar** s_collection = NULL;
		gint s_collection_length1 = 0;
		gint _s_collection_size_ = 0;
		gint s_it = 0;
		s_collection = _tmp17_;
		s_collection_length1 = _tmp17__length1;
		for (s_it = 0; s_it < _tmp17__length1; s_it = s_it + 1) {
			gchar* _tmp18_;
			gchar* s = NULL;
			_tmp18_ = g_strdup (s_collection[s_it]);
			s = _tmp18_;
			{
				GtkLabel* l = NULL;
				const gchar* _tmp19_;
				gchar* _tmp20_;
				gchar* _tmp21_;
				GtkLabel* _tmp22_;
				GtkLabel* _tmp23_;
				GtkLabel* _tmp24_;
				GtkGrid* _tmp25_;
				GtkLabel* _tmp26_;
				gint _tmp27_;
				gint _tmp28_;
				_tmp19_ = s;
				_tmp20_ = g_strconcat (_tmp19_, ":", NULL);
				_tmp21_ = _tmp20_;
				_tmp22_ = (GtkLabel*) gtk_label_new (_tmp21_);
				g_object_ref_sink (_tmp22_);
				_tmp23_ = _tmp22_;
				_g_free0 (_tmp21_);
				l = _tmp23_;
				_tmp24_ = l;
				gtk_label_set_xalign (_tmp24_, (gfloat) 0);
				_tmp25_ = spinboxgrid;
				_tmp26_ = l;
				_tmp27_ = index;
				gtk_grid_attach (_tmp25_, (GtkWidget*) _tmp26_, 0, _tmp27_, 1, 1);
				_tmp28_ = index;
				index = _tmp28_ + 1;
				_g_object_unref0 (l);
				_g_free0 (s);
			}
		}
	}
	_tmp29_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 0, (gdouble) 255, (gdouble) 1);
	g_object_ref_sink (_tmp29_);
	_g_object_unref0 (self->priv->redbutton);
	self->priv->redbutton = _tmp29_;
	_tmp30_ = self->priv->redbutton;
	g_signal_connect_object (_tmp30_, "value-changed", (GCallback) _color_picker_get_fromrgbspins_gtk_spin_button_value_changed, self, 0);
	_tmp31_ = spinboxgrid;
	_tmp32_ = self->priv->redbutton;
	gtk_grid_attach (_tmp31_, (GtkWidget*) _tmp32_, 1, 0, 1, 1);
	_tmp33_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 0, (gdouble) 255, (gdouble) 1);
	g_object_ref_sink (_tmp33_);
	_g_object_unref0 (self->priv->greenbutton);
	self->priv->greenbutton = _tmp33_;
	_tmp34_ = self->priv->greenbutton;
	g_signal_connect_object (_tmp34_, "value-changed", (GCallback) _color_picker_get_fromrgbspins_gtk_spin_button_value_changed, self, 0);
	_tmp35_ = spinboxgrid;
	_tmp36_ = self->priv->greenbutton;
	gtk_grid_attach (_tmp35_, (GtkWidget*) _tmp36_, 1, 1, 1, 1);
	_tmp37_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 0, (gdouble) 255, (gdouble) 1);
	g_object_ref_sink (_tmp37_);
	_g_object_unref0 (self->priv->bluebutton);
	self->priv->bluebutton = _tmp37_;
	_tmp38_ = self->priv->bluebutton;
	g_signal_connect_object (_tmp38_, "value-changed", (GCallback) _color_picker_get_fromrgbspins_gtk_spin_button_value_changed, self, 0);
	_tmp39_ = spinboxgrid;
	_tmp40_ = self->priv->bluebutton;
	gtk_grid_attach (_tmp39_, (GtkWidget*) _tmp40_, 1, 2, 1, 1);
	_tmp41_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	g_object_ref_sink (_tmp41_);
	buttonbox = _tmp41_;
	_tmp42_ = maingrid;
	gtk_grid_attach (_tmp42_, (GtkWidget*) buttonbox, 1, 11, 1, 1);
	_tmp43_ = (GtkButton*) gtk_button_new_with_label ("Choose");
	g_object_ref_sink (_tmp43_);
	apply_button = _tmp43_;
	g_signal_connect_object (apply_button, "clicked", (GCallback) _color_picker_update_gsettings_gtk_button_clicked, self, 0);
	gtk_widget_set_size_request ((GtkWidget*) apply_button, 100, 10);
	gtk_box_pack_end (buttonbox, (GtkWidget*) apply_button, FALSE, FALSE, (guint) 0);
	_tmp44_ = (GtkButton*) gtk_button_new_with_label ("Cancel");
	g_object_ref_sink (_tmp44_);
	cancel_button = _tmp44_;
	g_signal_connect_object (cancel_button, "clicked", (GCallback) ___lambda4__gtk_button_clicked, self, 0);
	gtk_widget_set_size_request ((GtkWidget*) cancel_button, 100, 10);
	gtk_box_pack_end (buttonbox, (GtkWidget*) cancel_button, FALSE, FALSE, (guint) 0);
	self->priv->red1 = 0.0;
	self->priv->green1 = 0.0;
	self->priv->blue1 = 0.0;
	g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 40, ___lambda5__gsource_func, g_object_ref (self), g_object_unref);
	color_picker_get_currgsettings (self);
	gtk_widget_show_all ((GtkWidget*) self);
	gtk_main ();
	_g_object_unref0 (cancel_button);
	_g_object_unref0 (apply_button);
	_g_object_unref0 (buttonbox);
	rgblabels = (_vala_array_free (rgblabels, rgblabels_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (spinboxgrid);
	_g_object_unref0 (maingrid);
	return self;
}


ColorPicker*
color_picker_new (void)
{
	return color_picker_construct (TYPE_COLOR_PICKER);
}


static void
_vala_array_add1 (gchar** * array,
                  int* length,
                  int* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void
color_picker_update_gsettings (ColorPicker* self,
                               GtkButton* button)
{
	gchar** new_arr = NULL;
	gchar** _tmp0_;
	gint new_arr_length1;
	gint _new_arr_size_;
	gint* newcolor = NULL;
	gint _tmp1_;
	gint* _tmp2_;
	gint newcolor_length1;
	gint _newcolor_size_;
	gint* _tmp3_;
	gint _tmp3__length1;
	GSettings* _tmp7_;
	gchar** _tmp8_;
	gint _tmp8__length1;
	g_return_if_fail (self != NULL);
	g_return_if_fail (button != NULL);
	_tmp0_ = g_new0 (gchar*, 0 + 1);
	new_arr = _tmp0_;
	new_arr_length1 = 0;
	_new_arr_size_ = new_arr_length1;
	_tmp2_ = color_picker_get_newcolor (self, &_tmp1_);
	newcolor = _tmp2_;
	newcolor_length1 = _tmp1_;
	_newcolor_size_ = newcolor_length1;
	_tmp3_ = newcolor;
	_tmp3__length1 = newcolor_length1;
	{
		gint* c_collection = NULL;
		gint c_collection_length1 = 0;
		gint _c_collection_size_ = 0;
		gint c_it = 0;
		c_collection = _tmp3_;
		c_collection_length1 = _tmp3__length1;
		for (c_it = 0; c_it < _tmp3__length1; c_it = c_it + 1) {
			gint c = 0;
			c = c_collection[c_it];
			{
				gchar** _tmp4_;
				gint _tmp4__length1;
				gint _tmp5_;
				gchar* _tmp6_;
				_tmp4_ = new_arr;
				_tmp4__length1 = new_arr_length1;
				_tmp5_ = c;
				_tmp6_ = g_strdup_printf ("%i", _tmp5_);
				_vala_array_add1 (&new_arr, &new_arr_length1, &_new_arr_size_, _tmp6_);
			}
		}
	}
	_tmp7_ = self->priv->settings;
	_tmp8_ = new_arr;
	_tmp8__length1 = new_arr_length1;
	g_settings_set_strv (_tmp7_, "textcolor", _tmp8_);
	gtk_main_quit ();
	newcolor = (g_free (newcolor), NULL);
	new_arr = (_vala_array_free (new_arr, new_arr_length1, (GDestroyNotify) g_free), NULL);
}


static void
_vala_array_add2 (gint* * array,
                  int* length,
                  int* size,
                  gint value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gint, *array, *size);
	}
	(*array)[(*length)++] = value;
}


static void
color_picker_get_currgsettings (ColorPicker* self)
{
	gint* cvals = NULL;
	gint* _tmp0_;
	gint cvals_length1;
	gint _cvals_size_;
	gchar** rgbvals = NULL;
	GSettings* _tmp1_;
	gchar** _tmp2_;
	gchar** _tmp3_;
	gint rgbvals_length1;
	gint _rgbvals_size_;
	gchar** _tmp4_;
	gint _tmp4__length1;
	GtkSpinButton* _tmp8_;
	gint* _tmp9_;
	gint _tmp9__length1;
	gint _tmp10_;
	GtkSpinButton* _tmp11_;
	gint* _tmp12_;
	gint _tmp12__length1;
	gint _tmp13_;
	GtkSpinButton* _tmp14_;
	gint* _tmp15_;
	gint _tmp15__length1;
	gint _tmp16_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_new0 (gint, 0);
	cvals = _tmp0_;
	cvals_length1 = 0;
	_cvals_size_ = cvals_length1;
	_tmp1_ = self->priv->settings;
	_tmp3_ = _tmp2_ = g_settings_get_strv (_tmp1_, "textcolor");
	rgbvals = _tmp3_;
	rgbvals_length1 = _vala_array_length (_tmp2_);
	_rgbvals_size_ = rgbvals_length1;
	_tmp4_ = rgbvals;
	_tmp4__length1 = rgbvals_length1;
	{
		gchar** s_collection = NULL;
		gint s_collection_length1 = 0;
		gint _s_collection_size_ = 0;
		gint s_it = 0;
		s_collection = _tmp4_;
		s_collection_length1 = _tmp4__length1;
		for (s_it = 0; s_it < _tmp4__length1; s_it = s_it + 1) {
			gchar* _tmp5_;
			gchar* s = NULL;
			_tmp5_ = g_strdup (s_collection[s_it]);
			s = _tmp5_;
			{
				gint* _tmp6_;
				gint _tmp6__length1;
				const gchar* _tmp7_;
				_tmp6_ = cvals;
				_tmp6__length1 = cvals_length1;
				_tmp7_ = s;
				_vala_array_add2 (&cvals, &cvals_length1, &_cvals_size_, atoi (_tmp7_));
				_g_free0 (s);
			}
		}
	}
	_tmp8_ = self->priv->redbutton;
	_tmp9_ = cvals;
	_tmp9__length1 = cvals_length1;
	_tmp10_ = _tmp9_[0];
	gtk_spin_button_set_value (_tmp8_, (gdouble) _tmp10_);
	_tmp11_ = self->priv->greenbutton;
	_tmp12_ = cvals;
	_tmp12__length1 = cvals_length1;
	_tmp13_ = _tmp12_[1];
	gtk_spin_button_set_value (_tmp11_, (gdouble) _tmp13_);
	_tmp14_ = self->priv->bluebutton;
	_tmp15_ = cvals;
	_tmp15__length1 = cvals_length1;
	_tmp16_ = _tmp15_[2];
	gtk_spin_button_set_value (_tmp14_, (gdouble) _tmp16_);
	rgbvals = (_vala_array_free (rgbvals, rgbvals_length1, (GDestroyNotify) g_free), NULL);
	cvals = (g_free (cvals), NULL);
}


static gint*
color_picker_get_newcolor (ColorPicker* self,
                           int* result_length1)
{
	gint* result = NULL;
	gint redval = 0;
	GtkSpinButton* _tmp0_;
	gint greenval = 0;
	GtkSpinButton* _tmp1_;
	gint blueval = 0;
	GtkSpinButton* _tmp2_;
	gint* _tmp3_;
	gint* _tmp4_;
	gint _tmp4__length1;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->redbutton;
	redval = (gint) gtk_spin_button_get_value (_tmp0_);
	_tmp1_ = self->priv->greenbutton;
	greenval = (gint) gtk_spin_button_get_value (_tmp1_);
	_tmp2_ = self->priv->bluebutton;
	blueval = (gint) gtk_spin_button_get_value (_tmp2_);
	_tmp3_ = g_new0 (gint, 3);
	_tmp3_[0] = redval;
	_tmp3_[1] = greenval;
	_tmp3_[2] = blueval;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = 3;
	if (result_length1) {
		*result_length1 = _tmp4__length1;
	}
	result = _tmp4_;
	return result;
}


static void
color_picker_get_fromrgbspins (ColorPicker* self,
                               GtkSpinButton* button)
{
	gint* ncolor = NULL;
	gint _tmp0_;
	gint* _tmp1_;
	gint ncolor_length1;
	gint _ncolor_size_;
	GdkRGBA setcolor = {0};
	gint _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	GdkRGBA _tmp5_ = {0};
	GtkColorChooserWidget* _tmp6_;
	GdkRGBA _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (button != NULL);
	_tmp1_ = color_picker_get_newcolor (self, &_tmp0_);
	ncolor = _tmp1_;
	ncolor_length1 = _tmp0_;
	_ncolor_size_ = ncolor_length1;
	_tmp2_ = ncolor[0];
	_tmp3_ = ncolor[1];
	_tmp4_ = ncolor[2];
	memset (&_tmp5_, 0, sizeof (GdkRGBA));
	_tmp5_.red = _tmp2_ / 255.0;
	_tmp5_.green = _tmp3_ / 255.0;
	_tmp5_.blue = _tmp4_ / 255.0;
	_tmp5_.alpha = (gdouble) 1;
	setcolor = _tmp5_;
	_tmp6_ = self->priv->color;
	_tmp7_ = setcolor;
	gtk_color_chooser_set_rgba ((GtkColorChooser*) _tmp6_, &_tmp7_);
	ncolor = (g_free (ncolor), NULL);
}


static void
color_picker_class_init (ColorPickerClass * klass)
{
	color_picker_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ColorPickerPrivate));
	G_OBJECT_CLASS (klass)->finalize = color_picker_finalize;
}


static void
color_picker_instance_init (ColorPicker * self)
{
	self->priv = COLOR_PICKER_GET_PRIVATE (self);
}


static void
color_picker_finalize (GObject * obj)
{
	ColorPicker * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_COLOR_PICKER, ColorPicker);
	_g_object_unref0 (self->priv->color);
	_g_object_unref0 (self->priv->settings);
	_g_object_unref0 (self->priv->redbutton);
	_g_object_unref0 (self->priv->greenbutton);
	_g_object_unref0 (self->priv->bluebutton);
	G_OBJECT_CLASS (color_picker_parent_class)->finalize (obj);
}


GType
color_picker_get_type (void)
{
	static volatile gsize color_picker_type_id__volatile = 0;
	if (g_once_init_enter (&color_picker_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ColorPickerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) color_picker_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ColorPicker), 0, (GInstanceInitFunc) color_picker_instance_init, NULL };
		GType color_picker_type_id;
		color_picker_type_id = g_type_register_static (gtk_window_get_type (), "ColorPicker", &g_define_type_info, 0);
		g_once_init_leave (&color_picker_type_id__volatile, color_picker_type_id);
	}
	return color_picker_type_id__volatile;
}


gint
_vala_main (gchar** args,
            int args_length1)
{
	gint result = 0;
	ColorPicker* win = NULL;
	ColorPicker* _tmp0_;
	gtk_init (&args_length1, &args);
	_tmp0_ = color_picker_new ();
	g_object_ref_sink (_tmp0_);
	win = _tmp0_;
	result = 0;
	_g_object_unref0 (win);
	return result;
}


int
main (int argc,
      char ** argv)
{
	return _vala_main (argv, argc);
}


static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint
_vala_array_length (gpointer array)
{
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



